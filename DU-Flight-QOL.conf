name: DU-Flight-QOL- Archaegeo v0.10 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        -- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu
        local pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
        local yawSpeedFactor =  1 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
        local rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
        local brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01
        local brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
        local autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)
        local autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01
        local turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is
        local turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
        require"src.slots"script={}function script.onStart()VERSION_NUMBER=0.10;pitchInput=0;rollInput=0;yawInput=0;brakeInput=0;Nav=Navigator.new(system,core,unit)Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})Nav.axisCommandManager:setTargetGroundAltitude(4)_autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)core.show()_autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")placeRadar=true;if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")if placeRadar then _autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")placeRadar=false end end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")if placeRadar then _autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")placeRadar=false end end;_autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")if placeRadar then _autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")placeRadar=false end;if antigrav~=nil then antigrav.show()end;if warpdrive~=nil then warpdrive.show()end;if gyro~=nil then gyro.show()end;if Nav.control.isRemoteControlled()==1 then system.freeze(1)end;gearExtended=Nav.control.isAnyLandingGearExtended()==1;if gearExtended then Nav.control.extendLandingGears()else Nav.control.retractLandingGears()end end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;if gyro~=nil then gyro.hide()end;core.hide()Nav.control.switchOffHeadlights()end;function script.onActionLoop(a)if a=="groundaltitudeup"then Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)elseif a=="groundaltitudedown"then Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)elseif a=="brake"then local b=Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)if b==axisCommandType.byTargetSpeed then local c=Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)if math.abs(c)>constants.epsilon then Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal,-utils.sign(c))end end elseif a=="speedup"then Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal,1.0)elseif a=="speeddown"then Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal,-1.0)end end;function script.onActionStart(a)if a=="gear"then gearExtended=not gearExtended;if gearExtended then Nav.control.extendLandingGears()else Nav.control.retractLandingGears()end elseif a=="light"then if Nav.control.isAnyHeadlightSwitchedOn()==1 then Nav.control.switchOffHeadlights()else Nav.control.switchOnHeadlights()end elseif a=="forward"then pitchInput=pitchInput-1 elseif a=="backward"then pitchInput=pitchInput+1 elseif a=="left"then rollInput=rollInput-1 elseif a=="right"then rollInput=rollInput+1 elseif a=="strafeleft"then Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral,-1.0)elseif a=="straferight"then Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral,1.0)elseif a=="up"then Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif a=="down"then Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif a=="groundaltitudeup"then Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)elseif a=="groundaltitudedown"then Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)elseif a=="yawright"then yawInput=yawInput-1 elseif a=="yawleft"then yawInput=yawInput+1 elseif a=="brake"then brakeInput=brakeInput+1;local b=Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)if b==axisCommandType.byTargetSpeed then local c=Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)if math.abs(c)>constants.epsilon then Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal,-utils.sign(c))end end elseif a=="booster"then Nav:toggleBoosters()elseif a=="stopengines"then Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)elseif a=="speedup"then Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal,5.0)elseif a=="speeddown"then Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal,-5.0)elseif a=="antigravity"then if antigrav~=nil then antigrav.toggle()end elseif a=="warp"then if warpdrive~=nil then warpdrive.activateWarp()end end end;function onUpdate()Nav:update()end;function script.onActionStop(a)if a=="forward"then pitchInput=pitchInput+1 elseif a=="backward"then pitchInput=pitchInput-1 elseif a=="left"then rollInput=rollInput+1 elseif a=="right"then rollInput=rollInput-1 elseif a=="strafeleft"then Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral,1.0)elseif a=="straferight"then Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral,-1.0)elseif a=="up"then Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical,-1.0)Nav.axisCommandManager:activateGroundEngineAltitudeStabilization()elseif a=="down"then Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical,1.0)Nav.axisCommandManager:activateGroundEngineAltitudeStabilization()elseif a=="yawright"then yawInput=yawInput+1 elseif a=="yawleft"then yawInput=yawInput-1 elseif a=="brake"then brakeInput=brakeInput-1 end end;function script.onTick(d)screen.setCenteredText("timer "..d.." ticked")end;function script.onFlush()local e=2;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)e=math.max(e,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)turnAssistFactor=math.max(turnAssistFactor,0.01)local f=pitchInput+system.getControlDeviceForwardInput()local g=rollInput+system.getControlDeviceYawInput()local h=yawInput-system.getControlDeviceLeftRightInput()local i=brakeInput;local j=vec3(core.getWorldVertical())local k=vec3(core.getConstructWorldOrientationUp())local l=vec3(core.getConstructWorldOrientationForward())local m=vec3(core.getConstructWorldOrientationRight())local n=vec3(core.getWorldVelocity())local o=vec3(core.getWorldVelocity()):normalize()local p=getRoll(j,l,m)local q=math.abs(p)local r=utils.sign(p)local s=vec3(core.getWorldAngularVelocity())local t=f*pitchSpeedFactor*m+g*rollSpeedFactor*l+h*yawSpeedFactor*k;if j:len()>0.01 and unit.getAtmosphereDensity()>0.0 then local u=1.0;if autoRoll==true and q>u and g==0 then local v=utils.clamp(0,q-30,q+30)if rollPID==nil then rollPID=pid.new(autoRollFactor*0.01,0,autoRollFactor*0.1)end;rollPID:inject(v-p)local w=rollPID:get()t=t+w*l end;local x=20.0;if turnAssist==true and q>x and f==0 and h==0 then local y=turnAssistFactor*0.1;local z=turnAssistFactor*0.025;local A=(q-x)/(180-x)*180;local B=0;if A<90 then B=A/90 elseif A<180 then B=(180-A)/90 end;B=B*B;local C=-r*z*(1.0-B)local D=y*B;t=t+D*m+C*k end end;local E=1;local F=0;local G=1;local H=e*(t-s)local I=vec3(core.getWorldAirFrictionAngularAcceleration())H=H-I;Nav:setEngineTorqueCommand('torque',H,E,'airfoil','','',G)local J=-i*(brakeSpeedFactor*n+brakeFlatFactor*o)Nav:setEngineForceCommand('brake',J)local K=''local L=vec3()local M=false;local N='thrust analog longitudinal'local b=Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)if b==axisCommandType.byThrottle then local O=Nav.axisCommandManager:composeAxisAccelerationFromThrottle(N,axisCommandId.longitudinal)Nav:setEngineForceCommand(N,O,E)elseif b==axisCommandType.byTargetSpeed then local O=Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)K=K..' , '..N;L=L+O;if Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)==0 or Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then M=true end end;local P='thrust analog lateral'local Q=Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)if Q==axisCommandType.byThrottle then local R=Nav.axisCommandManager:composeAxisAccelerationFromThrottle(P,axisCommandId.lateral)Nav:setEngineForceCommand(P,R,E)elseif Q==axisCommandType.byTargetSpeed then local S=Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)K=K..' , '..P;L=L+S end;local T='thrust analog vertical'local U=Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)if U==axisCommandType.byThrottle then local V=Nav.axisCommandManager:composeAxisAccelerationFromThrottle(T,axisCommandId.vertical)Nav:setEngineForceCommand(T,V,E,'airfoil','ground','',G)elseif U==axisCommandType.byTargetSpeed then local W=Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)K=K..' , '..T;L=L+W end;if L:len()>constants.epsilon then if brakeInput~=0 or M or math.abs(o:dot(l))<0.95 then K=K..', brake'end;Nav:setEngineForceCommand(K,L,F,'','','',G)end;Nav:setBoosterCommand('rocket_engine')end;function script.onMouseDown(X,Y)end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
